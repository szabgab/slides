# Variable ownership in Rust
{id: ownership}

## Stack and Heap
{id: stack-and-heap}

* Stack  (fixed size, push/pop)
* Heap   (any size, allocate/free)

## Integers are copies
{id: integers-are-copies}

* Make the copy mutable

![](examples/ownership/integers/src/main.rs)
![](examples/ownership/integers/out.out)

## Passing integers to functions and returning integer
{id: passing-integers-to-functions-and-returning-integer}

![](examples/ownership/integers-in-function/src/main.rs)
![](examples/ownership/integers-in-function/out.out)

## Mutable integers are copies
{id: mutable-integers-are-copies}

* Both are mutable

![](examples/ownership/mutable-integers/src/main.rs)
![](examples/ownership/mutable-integers/out.out)

## Immutable integers are copies
{id: immutable-integer-are-copies}

* Only the original is mutable, the copy is not

![](examples/ownership/immutable-integer/src/main.rs)
![](examples/ownership/immutable-integer/out.out)

## Pass integer to function return changed value
{id: pass-integer-to-function-return-changed-value}

![](examples/ownership/mutable-integers-in-function-return/src/main.rs)
![](examples/ownership/mutable-integers-in-function-return/out.out)

## Pass mutable reference of integer to function
{id: pass-mutable-reference-of-inteher-to-function}

![](examples/ownership/mutable-integers-in-function/src/main.rs)
![](examples/ownership/mutable-integers-in-function/out.out)


## Literal string
{id: literal-string}

* The variable "name" points to a literal string. (aka. hard-coded string). The string can never change
* Because the variable is not mutable, we cannot even replace the content. (See error message generated by the commented out code.)

![](examples/ownership/literal_string.rs)
![](examples/ownership/literal_string.out)
![](examples/ownership/literal_string.err)

## Literal string in mutable variable
{id: literal-string-in-mutable-variable}
{i: mut}

* The variable can be made mutable using `mut`. Then it can be replaced, but the literal (hard-coded) string is baked into the code of the program and thus it cannot be changed runtime.
* This is an `str` type.

![](examples/ownership/literal_string_in_mutable_variable.rs)
![](examples/ownership/literal_string_in_mutable_variable.out)
![](examples/ownership/literal_string_in_mutable_variable.err)

## Passing literal string to function
{id: passing-literal-string-to-function}

![](examples/ownership/str.rs)
![](examples/ownership/str.out)

## Mutable string in immutable variable
{id: mutable-string-in-immutable-variable}
{i: push_str}

* If we initialize the variable using `String::from` then the literal value is copied to the heap and it can be changed.
* But if the variable is not mutable, then what's the point?

![](examples/ownership/mutable_string_in_immutable_variable.rs)
![](examples/ownership/mutable_string_in_immutable_variable.out)
![](examples/ownership/mutable_string_in_immutable_variable.err)


## Mutable string
{id: mutable-string}
{i: push_str}

* If we initialize the varibale using `String::from` and make it mutable then we can change the string.

![](examples/ownership/mutable_string.rs)
![](examples/ownership/mutable_string.out)


## Move strings
{id: move-string}

* We can assign a variable that contains a "mutable string" to another variable
* But this is called a "move" as we move the ownership of the data to the new variable.
* After that we cannot use the old variable any more.
* This will be fun when would like to change one of the variables or if we pass it to a function.

* The variable "owns" the data.
* If we assign the variable to another variable, we pass (move) the ownership.

![](examples/ownership/move_string.rs)
![](examples/ownership/move_string.out)
![](examples/ownership/move_string.err)

## Move mutable string
{id: move-mutable-string}

![](examples/ownership/move_mutable_string.rs)


## Rust clone a String
{id: rust-ownership-clone-string}
{i: clone}

* In some cases what we will want is to copy the content of the variable.
* For this we can use the `clone` method.

![](examples/ownership/string_clone.rs)

## Rust ownership - borrow String
{id: rust-ownership-borrow-string}
{i: &}

* We can tell Rust that a variable borrows the ownership.
* In this case both variables have (read) access to the variable.
* We can have as many (read) borrows as we need.

![](examples/ownership/string_borrow.rs)

## Rust ownership string in function
{id: rust-ownership-string-in-function}

![](examples/ownership/string_function.rs)

## Rust ownership borrow string in function
{id: rust-ownership-borrow-string-in-function}
{i: &}

* When passing the variable we need to prefix it with `&`.
* In the function definition we also include the `&` in-front of the type.
* Inside the function we can prefix it with `*` to dereference the variable but in general we don't need to as Rust figures that out.

![](examples/ownership/string_function_borrow.rs)

## Rust function to change string
{id: rust-function-to-change-string}

![](examples/ownership/change_string.rs)

## Rust function to change integer (i32)
{id: rust-function-to-change-integer}

![](examples/ownership/change_i32.rs)

![](examples/ownership/owner.rs)

## Lifetime annotation
{id: lifetime-annotation}

![](examples/ownership/lifetime_annotation.rs)

## Change vector of structs
{id: change-vector-of-structs}

![](examples/ownership/change_vector_of_structs.rs)
![](examples/ownership/change_vector_of_structs.out)


